/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useCallback, useEffect, useRef, useState } from "react";
import { useGLTF, useAnimations, Text } from "@react-three/drei";
import { a } from "@react-spring/three";
import isIslandScene from "../assets/modal1.glb";
import { useFrame, useThree } from "@react-three/fiber";
import { isTypedArray } from "three/src/animation/AnimationUtils.js";
export function Model({
  isRotating,
  setIsRotating,
  setCurrentStage,
  ...props
}) {
  const group = useRef();
    const isPanning = useRef(false); // Track panning state

  const { gl, viewport } = useThree();
  const { nodes, materials, animations } = useGLTF(isIslandScene);
  const [shiftPressed, setShiftPressed] = useState(false); // Check if Shift key is pressed

  const { actions } = useAnimations(animations, group);
  const zoomLevel = useRef(1);
  const lastX = useRef(0);
  const lastY = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;

  const handlePointerDown = useCallback((e) => {
    e.stopPropagation();
    e.preventDefault();
    setIsRotating(true);
    lastX.current = e.clientX || e.touches?.[0]?.clientX;
    lastY.current = e.clientY || e.touches?.[0]?.clientY;
  }, []);
  
  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("pointermove", handlePointerMove);
    return () => {
      canvas.removeEventListener("pointerdown", handlePointerDown);
      canvas.removeEventListener("pointerup", handlePointerUp);
      canvas.removeEventListener("pointermove", handlePointerMove);
    };
  }, [gl, handlePointerDown]);
  

  const handlePointerUp = () => {
    setIsRotating(false);
    isPanning.current = false;
  };

  const handlePointerMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    const clientX = e.clientX || e.touches?.[0]?.clientX;
    const clientY = e.clientY || e.touches?.[0]?.clientY;

    const deltaX = (clientX - lastX.current) / viewport.width;
    const deltaY = (clientY - lastY.current) / viewport.height;

    if (shiftPressed) {
      // Panning Mode (Shift + Mouse Move)
      isPanning.current = true;
      group.current.position.x += deltaX * 2;
      group.current.position.y -= deltaY * 2;
    } else if (isRotating) {
      // Rotating Mode (Default)
      group.current.rotation.y += deltaX * 0.02 * Math.PI;
      rotationSpeed.current = deltaX * 0.02 * Math.PI;
    }

    lastX.current = clientX;
    lastY.current = clientY;
  };

  const handleKeyDown = (e) => {
    if (e.key === "Shift") {
      setShiftPressed(true);
    }

    switch (e.key) {
      case "ArrowLeft":
        group.current.position.x -= 0.1; // Move left
        break;
      case "ArrowRight":
        group.current.position.x += 0.1; // Move right
        break;
      case "ArrowUp":
        group.current.position.y += 0.1; // Move up
        break;
      case "ArrowDown":
        group.current.position.y -= 0.1; // Move down
        break;
      case "+":
        zoomLevel.current = Math.max(zoomLevel.current - 0.05, 0.5);
        group.current.scale.set(
          zoomLevel.current,
          zoomLevel.current,
          zoomLevel.current
        );
        break;
      case "-":
        zoomLevel.current = Math.min(zoomLevel.current + 0.05, 1);
        group.current.scale.set(
          zoomLevel.current,
          zoomLevel.current,
          zoomLevel.current
        );
        break;
    }
  };

  const handleKeyUp = (e) => {
    if (e.key === "Shift") {
      setShiftPressed(false);
    }
  };

  useFrame(() => {
    if (!isRotating) {
      rotationSpeed.current *= dampingFactor;
      if (Math.abs(rotationSpeed.current) < 0.001) {
        rotationSpeed.current = 0;
      }
      group.current.rotation.y += rotationSpeed.current;
    } else {
      const rotation = group.current.rotation.y;
      const normalizedRotation =
        ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
      let newStage = null;
  
      if (normalizedRotation >= 5.45 && normalizedRotation <= 5.85) {
        newStage = 4;
      } else if (normalizedRotation >= 0.85 && normalizedRotation <= 1.3) {
        newStage = 3;
      } else if (normalizedRotation >= 2.4 && normalizedRotation <= 2.6) {
        newStage = 2;
      } else if (normalizedRotation >= 4.25 && normalizedRotation <= 4.75) {
        newStage = 1;
      }
  
      // Prevent unnecessary updates
      setCurrentStage((prevStage) =>
        prevStage !== newStage ? newStage : prevStage
      );
    }
  });
  
  const handleWheel = (e) => {
    e.preventDefault();
    zoomLevel.current = Math.min(
      Math.max(zoomLevel.current - e.deltaY * 0.001, 0.5),
      1
    );
    group.current.scale.set(
      zoomLevel.current,
      zoomLevel.current,
      zoomLevel.current
    );
  };
  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("pointermove", handlePointerMove);
    canvas.addEventListener("wheel", handleWheel, { passive: false });
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);

    return () => {
      canvas.removeEventListener("pointerdown", handlePointerDown);
      canvas.removeEventListener("pointerup", handlePointerUp);
      canvas.removeEventListener("pointermove", handlePointerMove);
      canvas.removeEventListener("wheel", handleWheel);
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);

  return (
    <a.group ref={group} {...props} dispose={null} scale={zoomLevel.current}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[Math.PI / 2, 0, -Math.PI]}>
          <group
            name="622331dd64104be7aa66e2f7d6b5dc8efbx"
            rotation={[-Math.PI, 0, 0]}
            scale={0.01}
          >
            <group name="Object_2">
              <group name="RootNode">
                <group
                  name="BezierCurve003"
                  position={[1208.747, -1918.884, -205.693]}
                  rotation={[0, 0, -Math.PI / 2]}
                  scale={[73.461, 114.205, 73.461]}
                >
                  <mesh
                    name="BezierCurve003_foliage_baked_0"
                    castShadow
                    receiveShadow
                    geometry={nodes.BezierCurve003_foliage_baked_0.geometry}
                    material={materials.foliage_baked}
                  />
                  <mesh
                    name="BezierCurve003_foliage_baked_0_1"
                    castShadow
                    receiveShadow
                    geometry={nodes.BezierCurve003_foliage_baked_0_1.geometry}
                    material={materials.foliage_baked}
                  />
                </group>
                <group
                  name="building_D_pipes"
                  position={[70.961, 517.462, 1209.234]}
                  rotation={[0, 0, Math.PI]}
                  scale={100}
                >
                  <mesh
                    name="building_D_pipes_pipes_moving_baked_0"
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.building_D_pipes_pipes_moving_baked_0.geometry
                    }
                    material={materials.pipes_moving_baked}
                  />
                </group>
                <group
                  name="rock_left"
                  position={[-1129.298, 4955.811, 5110.5]}
                  rotation={[0, 0, -Math.PI / 2]}
                  scale={100}
                >
                  <mesh
                    name="rock_left_stones_0"
                    castShadow
                    receiveShadow
                    geometry={nodes.rock_left_stones_0.geometry}
                    material={materials.stones}
                  />
                  <mesh
                    name="rock_left_ROCKS_SMALL_0"
                    castShadow
                    receiveShadow
                    geometry={nodes.rock_left_ROCKS_SMALL_0.geometry}
                    material={materials.ROCKS_SMALL}
                  />
                  <mesh
                    name="rock_left_rock_A_0"
                    castShadow
                    receiveShadow
                    geometry={nodes.rock_left_rock_A_0.geometry}
                    material={materials.rock_A}
                  />
                  <mesh
                    name="rock_left_rock_B_0"
                    castShadow
                    receiveShadow
                    geometry={nodes.rock_left_rock_B_0.geometry}
                    material={materials.rock_B}
                  />
                </group>
                <group
                  name="stone_small_C001"
                  position={[-1129.298, 4955.811, 5110.5]}
                  rotation={[0, 0, -Math.PI / 2]}
                  scale={100}
                >
                  <mesh
                    name="stone_small_C001_rock_top_baked_0"
                    castShadow
                    receiveShadow
                    geometry={nodes.stone_small_C001_rock_top_baked_0.geometry}
                    material={materials.rock_top_baked}
                  />
                </group>
                <group
                  name="stone_small_C002"
                  position={[-1129.298, 4955.811, 5110.5]}
                  rotation={[0, 0, -Math.PI / 2]}
                  scale={100}
                >
                  <mesh
                    name="stone_small_C002_rock_right_baked_0"
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.stone_small_C002_rock_right_baked_0.geometry
                    }
                    material={materials.rock_right_baked}
                  />
                </group>
                <group
                  name="rock_middle"
                  position={[-1129.298, 4955.811, 5110.5]}
                  rotation={[0, 0, -Math.PI / 2]}
                  scale={100}
                >
                  <mesh
                    name="rock_middle_rock_middle_baked_0"
                    castShadow
                    receiveShadow
                    geometry={nodes.rock_middle_rock_middle_baked_0.geometry}
                    material={materials.rock_middle_baked}
                  />
                </group>
                <group
                  name="bridge_suspended002"
                  position={[-2351.661, 3178, 1078.609]}
                  rotation={[0, 0, -2.834]}
                  scale={100}
                >
                  <mesh
                    name="bridge_suspended002_platform_calm_0"
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.bridge_suspended002_platform_calm_0.geometry
                    }
                    material={materials.platform_calm}
                  />
                </group>
                <Text
              position={[10, 5, 0]} // Adjust position to match edges
              fontSize={1}
              color="red"
              anchorX="center"
              anchorY="middle"
              onClick={() => console.log("Left Edge Clicked")}
            >
              Left Edge
            </Text>
                <group
                  name="Armature001"
                  position={[-154.142, 606.122, -66.65]}
                  rotation={[0, 0, -Math.PI / 2]}
                  scale={100}
                >
                  <group name="Object_23">
                    <primitive object={nodes._rootJoint} />
                  </group>
                </group>
                <group
                  name="bridge_suspended010"
                  position={[641.867, -5206.882, 755.615]}
                  rotation={[0, 0, -Math.PI / 2]}
                  scale={100}
                >
                  <mesh
                    name="bridge_suspended010_platform_unstable_baked_0"
                    castShadow
                    receiveShadow
                    geometry={
                      nodes.bridge_suspended010_platform_unstable_baked_0
                        .geometry
                    }
                    material={materials.platform_unstable_baked}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </a.group>
  );
}
